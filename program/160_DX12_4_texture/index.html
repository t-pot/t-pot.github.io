<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <title>t-pot『DirectX 12: テクスチャの描画』</title>
  <link rel="stylesheet" type="text/css" href="../if.css">
</head>
<body>

<div class="contents">
<div style="text-align: center;">
<br style="clear: both;">
<br style="clear: both;">
<h1>DirectX 12: テクスチャの描画</h1><br>
<h3>～ DirectX 12: Draw a textured polygone ～</h3>
<br style="clear: both;">
<br style="clear: both;">
<br style="clear: both;">
<a href="http://t-pot.com/160_DX12_4_texture/">
  <img alt="executed image" src="title.png" style="width: 80%;" />
</a>
<br>
<hr>
</div> <!-- center -->

<h2>■はじめに</h2>

<p>
    今回はポリゴンにテクスチャを貼ってみます。
</p>


<p>
ソースコードは、GitHubに上がっているものを見てもらえればと思います。<br>
</p>
<ul><li><a href="https://github.com/t-pot/160_DX12_texture">https://github.com/t-pot/160_DX12_texture</a></li></ul>

<hr>


<h2>■今回の流れ</h2>
<p>
今回はポリゴンにランダムな色のテクスチャを貼ってみます。
テクスチャを貼る際に重要な要素としてはルート署名があります。
ルート署名でテクスチャのリソースを指定したり、サンプラーを記述します。
</p>

<p>
今回の流れは大きく変わりません。頂点バッファーを作成した後にテクスチャを作成する処理が追加されます。
その他は、今までに記載した部分に変更を加えていくことが多いです。
</p>
<p>
太文字の部分が今回の変更点で、色がついている部分が今回の追加部分です。
</p>

<p><img src="160_1.png" style="max-width: 1701px; width: 100%;" alt="本日のフロー"></p>

<hr>
<h2>■ テクスチャを読み込むシェーダー</h2>

<h3>ピクセルシェーダー</h3>
<p>
  分かりやすい変更点としては、シェーダーでテクスチャ（画像）を読み込みます。
  テクスチャを読み込むには、テクスチャのオプジェクトで、Sampleメソッドを使います。
  今までは色の情報を直接出力していましたが、テクスチャを読み込んた値の色と置き替えます。<br>
  引数としては、読み込み方を指定するサンプラーのオブジェクトと、
  どの場所の画像を読み込むのかを指定するテクスチャ座標を与えます。
</p>
<p>
[shaders.hlsl]<br>
    <img src="160_2.png" style="max-width: 498px; width: 100%;" alt="ピクセルシェーダー">
</p>
<p>
  テクスチャやサンプラーのオブジェクトは、シェーダーファイル内で、グローバスオブジェクトとして宣言します。<br>
  ここで「register」というキーワードを使って、どのレジスタに割り当てるかを指定します。
  テクスチャはt、サンプラーはsというレジスタに割り当てられることが決まっています。
  テクスチャやサンプラーは複数もてるので、それらを区別するためにレジスタに番号を付けてしています。
  番号は0から始まります。それぞれの値の上限はぼちぼちありますが、しばらく気にしなくて良いでしょう。
</p>
<p>
[shaders.hlsl]<br>
    <img src="160_3.png" style="max-width: 328px; width: 100%;" alt="グローバル変数の宣言">
</p>
<h3>頂点シェーダー</h3>
<p>
もう1つのピクセルシェーダーのへの入力であるテクスチャ座標は、頂点シェーダーから渡されます。<br>
頂点シェーダーが出力する構造体を修正して、色からテクスチャ座標を出力するようにします。<br>
テクスチャ座標の出力では、「TEXCOORD」のセマンティックを使います。TEXCOORDnに続いて番号を
指定することで、複数のテクスチャ座標を出力できます。
</p>
<p>
[shaders.hlsl]<br>
    <img src="160_4.png" style="max-width: 320px; width: 100%;" alt="シェーダー間データ">
</p>
<p>
頂点シェーダーでは、入力から色をコピーしていたものをテクスチャ座標に置き替えます。<br>
したがって、頂点シェーダーにテクスチャ座標を入力するのが、秘儀に必要な作業になります。
</p>
<p>
[shaders.hlsl]<br>
    <img src="160_5.png" style="max-width: 579px; width: 100%;" alt="頂点シェーダー">
</p>
<hr>
<h2>■ 頂点データへのテクスチャ座標の導入</h2>
<p>
頂点シェーダーにデータを渡すのを決めるのは、頂点レイアウトです。
入力要素記述子を差し替えて、色ではなくテクスチャ座標を渡すようにします。<br>
まず、CPU側の頂点データの構造体を書き換えます。
整数で色を指定したメンバーを「XMFLOAT2」の「テクスチャ座標」に置き替えます。
</p>
<p>
[Appliaction.h]<br>
    <img src="160_6.png" style="max-width: 361px; width: 100%;" alt="頂点データ構造体">
</p>
<p>
  次にD3D12_INPUT_ELEMENT_DESC構造体を書き換えます。
  今までの色のメンバーをテクスチャ座標に置き換えます。具体的には、セマンティック文字列をTEXCOORDに、
  フォーマットをDXGI_FORMAT_R32G32_FLOAT（2成分の浮動小数点数）に変更します。
</p>
<p>
[Appliaction.cpp]<br>
    <img src="160_7.png" style="max-width: 721px; width: 100%;" alt="頂点レイアウト宣言">
</p>
<p>
  最後に、頂点データを作成するときに、色のメンバーに値を代入していた部分を、テクスチャ座標に変更します。<br>
  今回は、使わない部分が発生してしまいますが、三角形の形状に重ねたようなテクスチャ座標を設定したいと思います。
</p>
<p>
    <img src="160_B.png" style="max-width: 1701px; width: 100%;" alt="ランダム模様の生成">
</p>
<p>
  具体的なテクスチャ座標の値は、次のように設定されます。
</p>  
<p>
[Appliaction.cpp]<br>
    <img src="160_8.png" style="max-width: 640px; width: 100%;" alt="頂点データ">
</p>
<hr>
<h2>■ テクスチャデータ</h2>
<p>
これで、テクスチャ座標のデータは適切に流され、ピクセルシェーダーでテクスチャを読み込む準備が整いました。
次は、テクスチャデータを作成します。<br>
テクスチャデータは、テクセルごとの色情報の配列のデータと、そのデータが画像であってシェーダーで読み込めることを示すメタデータで構成されます。<br>
メタデータは、SRV(Shader Resource View)というスクリプタヒープに登録されるデスクリプターの1つで、
テクスチャのデータアドレスやフォーマットなどのテクスチャデータの情報を格納します。
</p>
<p>
    <img src="160_9.png" style="max-width: 277px; width: 100%;" alt="テクスチャメモリのイメージ">
</p>
<h3>メンバー変数</h3>
<p>
  テクスチャの色情報は、頂点バッファーと同じようにID3D12Resourceインターフェイスのリソースとして扱われます。<br>
  アプリケーションのメンバー変数として登録します。
</p>
<p>
[Appliaction.h]<br>
    <img src="160_10.png" style="max-width: 453px; width: 100%;" alt="テクスチャリソースの宣言">
</p>
<p>
  また、SRVのデスクリプターヒープも、RTVのデスクリプターと同じように、メンバー変数として登録します。
</p>
<p>
[Appliaction.h]<br>
    <img src="160_11.png" style="max-width: 564px; width: 100%;" alt="SRVヒープの宣言">
</p>
<h3>テクスチャリソースの確保</h3>
<p>
  テクスチャリソースを作成します。
  D3D12_RESOURCE_DESC構造体を使って、テクスチャの大きさやフォーマット、使用法などを指定します。
  今回は、[0,255]の8ビットの4成分で、256平方のテクスチャを作成します。<br>
  テクスチャ記述子とメモリの確保の仕方のヒーププロパティを設定して、
  CreateCommittedResourceメソッドでテクスチャリソースを作成します。
</p>
<p>
[Appliaction.cpp]<br>
    <img src="160_12.png" style="max-width: 591px; width: 100%;" alt="テクスチャリソースの確保">
</p>
<h3>テクスチャデータの作成</h3>
<p>
  次に、テクスチャをランダムな色で埋め尽くしましょう。<br>
  テクスチャに値を記録する方法はいくつかあるのですが、今回は、別のテクスチャにデータを記録し、
  それをテクスチャリソースにコピーする方法を取ります。<br>
  シェーダーで読み込めるテクスチャのリソースのヒープにD3D12_HEAP_TYPE_DEFAULTを指定しましたが、
  この設定はテクスチャのメモリに直接書き込むことはできません。
  書き込むことができるヒープであるD3D12_HEAP_TYPE_UPLOADを指定したテクスチャアップロードヒープというテクスチャリソースを作成し、
  そこにテクスチャデータを書き込んでから、テクスチャリソースにコピーします。
</p>
<p>
  先ずは、テクスチャアップロードヒープのリソースを保持する変数を用意しておきます。
</p>
<p>
[Appliaction.cpp]<br>
    <img src="160_13.png" style="max-width: 656px; width: 100%;" alt="テクスチャアップロードヒープの定義">
</p>
<p>
  D3D12_HEAP_TYPE_UPLOADを指定したヒーププロパティでアップロード用のテクスチャリソースを作成します。
</p>
<p>
[Appliaction.cpp]<br>
    <img src="160_14.png" style="max-width: 705px; width: 100%;" alt="テクスチャアップロードヒープの生成">
</p>
<p>
次に、ランダムな色のデータを用意して、そのアドレスやサイズをD3D12_SUBRESOURCE_DATAに設定して、
アップロード用のテクスチャリソースにコピーします。<br>
実際の処理は、d3dx12.hライブラリのUpdateSubresources関数を使ってコピーを行っています。
行っていることはリソースをCPUがアクセスできるメモリにマッピングして、その場所にデータをコピーして転送しています。
時間がある時に、コードを1通り追っておくと良いでしょう。
</p>
<p>
[Appliaction.cpp]<br>
    <img src="160_15.png" style="max-width: 718px; width: 100%;" alt="テクスチャデータの転送">
</p>
<p>
  ランダムな色の生成は、C++のSTLの乱数ライブラリを用いて256^3の一様乱数として生成しています。
</p>
<p>
[Appliaction.cpp]<br>
    <img src="160_A.png" style="max-width: 550px; width: 100%;" alt="ランダム模様の生成">
</p>
<h3>SRVヒープ</h3>
<p>
  テクスチャリソースを作成したら、SRVヒープにテクスチャリソースのデスクリプターを登録します。<br>
  テクスチャリソースのデスクリプターは、D3D12_SHADER_RESOURCE_VIEW_DESC構造体で作成します。
  テクスチャのフォーマットや、テクスチャの型、テクスチャのミップマップレベルなどを指定して、
  CreateShaderResourceViewメソッドで生成します。
</p>
<p>
[Appliaction.cpp]<br>
    <img src="160_16.png" style="max-width: 672px; width: 100%;" alt="SRVヒープの作成">
</p>
<h3>テクスチャデータの転送待ち</h3>
<p>
  あと大事なことは、テクスチャデータの転送が終わるまで待つことです。
  テクスチャデータの転送は、GPUが行うので、CPUがGPUの処理が終わるのを待つ必要があります。
  今までに待つ処理はありましたが、実際にはコマンドリストをすぐに閉じてしまっていました。
  これを最初に閉じるのを止めて、テクスチャデータの転送を記述した後に閉じて処理を待つことで、
  テクスチャデータがGPUが参照できるようになってから先に進みます。<br>
  今まで閉じていた処理を削除します（このプロジェクトではコメントアウトにしました）。
</p>
<p>
[Appliaction.cpp]<br>
    <img src="160_17.png" style="max-width: 578px; width: 100%;" alt="今までのCloseの消去">
</p>
<p>
  テクスチャのコピーに関する処理を追加した後にコマンドリストを閉じて、
  ExecuteCommandListsメソッドでコマンドリストを実行します。
</p>
<p>
[Appliaction.cpp]<br>
    <img src="160_18.png" style="max-width: 659px; width: 100%;" alt="転送待ち">
</p>
<hr>
<h2>■ ルート署名</h2>
<p>
  テクスチャ座標を設定して、テクスチャデータを作成しました。
  まだ行っていないことは、シェーダーのレジスタ番号とテクスチャデータを結びつけることです。
  その情報は、ルート署名に記述します。<br>
  ルート署名は、シェーダーに渡すデータの構造を定義します。
  ルート署名のパラメーターとしてシェーダーのレジスタ番号を指定するのですが、
  複雑な設定耐えられるように、デスクリプターレンジという範囲を指定する機能を使ってレジスタ番号を登録します。
  また、デスクリプターレンジもルートパラメーターという構造体を通して指定します。<br>
  サンプラーは、ルート署名記述子から個数と配列の形で指定できます。
</p>
<p>
    <img src="160_19.png" style="max-width: 998px; width: 100%;" alt="ルート署名記述子の構成">
</p>
<p>
  最初にルートシグネチャのバージョン管理を行います。
  ルートシグネチャは1.1が執筆時点で最新で、1.0との違いは、デスクリプターレンジが静的であれば、
  その情報を利用してGPUが最適化を行うことができるという点（らしい）です。<br>
  ここでは、バージョン1.1の機能が使えるかチェックして使えないようなら、バージョン1.0を使うようにします。  
</p>
<p>
[Appliaction.cpp]<br>
    <img src="160_20.png" style="max-width: 636px; width: 100%;" alt="ルート署名のバージョンの決定">
</p>
<p>
  次に、SRVのデスクリプターレンジを作成して、ルートパラメーターにそれを設定します。
  ルートパラメーターでD3D12_SHADER_VISIBILITY_PIXELが設定されています。
  これは、テクスチャがピクセルシェーダーでしか使われない（頂点シェーダーで使われない）という事を示しています。
</p>
<p>
[Appliaction.cpp]<br>
    <img src="160_21.png" style="max-width: 542px; width: 100%;" alt="デスクリプタレンジ、ルートパラメータの作成">
</p>
<p>
  サンプラー記述子もここで作成します。
  サンプラー記述子は、テクスチャの座標をどのように取得するかを指定します。
  ここでは、フィルタリングをポイント（滑らかな補間がされない）を指定するとともに、
  アドレスモードをBORDERにしてテクスチャ座標が[0,1]の範囲の外に出たらD3D12_STATIC_BORDER_COLOR_TRANSPARENT_BLACK（黒）の色になる指定をしています。<br>
  フィルタリングを線形補間にすると、拡大した際に滑らかな色の補間がされるようになるので、変えて試してみてください。
</p>
<p>
[Appliaction.cpp]<br>
    <img src="160_22.png" style="max-width: 654px; width: 100%;" alt="サンプラー記述子の作成">
</p>
<p>
  今まで作成したルート署名記述子やサンプラー記述子を使って、ルート署名記述子を構成します。
</p>
<p>
[Appliaction.cpp]<br>
    <img src="160_23.png" style="max-width: 743px; width: 100%;" alt="ルート署名記述子の作成">
</p>
<p>
  ルート署名記述子をシリアライズしてバイナリデータ（署名）を作成したら、その署名を使ってルート署名を作成します。
</p>
<p>
[Appliaction.cpp]<br>
    <img src="160_24.png" style="max-width: 667px; width: 100%;" alt="ルート署名の生成">
</p>
<h3>dxguidライブラリの組み込み</h3>
<p>
  さて、実際に組み込んで見たら、ライブラリが足りないと言われたので、dxguidライブラリを組み込みました。
</p>
<p>
[framework.h]<br>
    <img src="160_25.png" style="max-width: 334px; width: 100%;" alt="dxguidライブラリの組み込み">
</p>
<hr>
<h2>■ 描画コマンド</h2>
<h3>テクスチャのバインド</h3>
<p>
  後は、メインループでテクスチャをバインドして描画するだけです。
  ルート署名の設定自体は行っていますが、実はテクスチャのデスクリプターヒープとシェーダーのレジスタ番号が結びついていません。
  そのため、ルートデスクリプターテーブルを使って、デスクリプターヒープとレジスタ番号を結びつけます。
  下の図は、オブジェクトを生成するための構造体の関係なのでオブジェクト間の関係とずれていますが、
  行っていることは、テクスチャのSRVのハンドル（アドレスと同じような情報）をルートデスクリプターテーブルに登録することで、
  テクスチャのデスクリプターヒープとレジスタ番号を結びつけています。
</p>
<p>
    <img src="160_26.png" style="max-width: 1269px; width: 100%;" alt="テクスチャのバインド">
</p>
<p>
  実際に行うのは、SetGraphicsRootDescriptorTableメソッドを使って、
  ルートデスクリプターテーブルに登録したデスクリプターヒープのGPUメモリのハンドルを設定します。
</p>
<p>
[Appliaction.cpp]<br>
    <img src="160_27.png" style="max-width: 559px; width: 100%;" alt="テクスチャのバインド">
</p>
  
  




<hr>
<h2>■ さいごに</h2>

<p>
ランダムな模様なので画像をはったというイメージから遠いですが、テクスチャをはったポリゴンが表示されました。<br>
次は3D描画でしょうか。
</p>
<br style="clear: both;">
<br style="clear: both;">
<br style="clear: both;">
<div style="text-align: center;">
<hr>
<p><a href="../index.html">もどる</a></p>
<p><a href="mailto:imagire@gmail.com">imagire@gmail.com</a></p>
</div><!-- center -->

</div>  <!-- contents -->
</body>
</html>
